<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Manifold: Manifold Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Manifold<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Robust computational geometry</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classmanifold_1_1_manifold.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classmanifold_1_1_manifold-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Manifold Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="manifold_8h_source.html">manifold.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmanifold_1_1_manifold_1_1_impl.html">Impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Information</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Details of the manifold </p>
</td></tr>
<tr class="memitem:a2c3e4bb40f36b262a5214e2da2bca9c5" id="r_a2c3e4bb40f36b262a5214e2da2bca9c5"><td class="memItemLeft" align="right" valign="top"><a id="a2c3e4bb40f36b262a5214e2da2bca9c5" name="a2c3e4bb40f36b262a5214e2da2bca9c5"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>Error</b> { <br />
&#160;&#160;<b>NoError</b>
, <b>NonFiniteVertex</b>
, <b>NotManifold</b>
, <b>VertexOutOfBounds</b>
, <br />
&#160;&#160;<b>PropertiesWrongLength</b>
, <b>MissingPositionProperties</b>
, <b>MergeVectorsDifferentLengths</b>
, <b>MergeIndexOutOfBounds</b>
, <br />
&#160;&#160;<b>TransformWrongLength</b>
, <b>RunIndexWrongLength</b>
, <b>FaceIDWrongLength</b>
, <b>InvalidConstruction</b>
<br />
 }</td></tr>
<tr class="separator:a2c3e4bb40f36b262a5214e2da2bca9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3711c029f2c9fe2d152455981a3b2d73" id="r_a3711c029f2c9fe2d152455981a3b2d73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemanifold.html#a4c4992743d3cf12ecd9f51b570a77a5f">MeshGL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a3711c029f2c9fe2d152455981a3b2d73">GetMeshGL</a> (ivec3 <a class="el" href="structmanifold_1_1_transform_iterator.html">normalIdx</a>=ivec3(0)) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a3711c029f2c9fe2d152455981a3b2d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf81b50cc39e7280e80cb8bf173e98bb" id="r_aaf81b50cc39e7280e80cb8bf173e98bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_mesh_g_l_p.html">MeshGL64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#aaf81b50cc39e7280e80cb8bf173e98bb">GetMeshGL64</a> (ivec3 <a class="el" href="structmanifold_1_1_transform_iterator.html">normalIdx</a>=ivec3(0)) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:aaf81b50cc39e7280e80cb8bf173e98bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e12342fc420701fbffd97025421575a" id="r_a8e12342fc420701fbffd97025421575a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a8e12342fc420701fbffd97025421575a">IsEmpty</a> () <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a8e12342fc420701fbffd97025421575a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423e2f2a67ccc0662a97e018b2c3886d" id="r_a423e2f2a67ccc0662a97e018b2c3886d"><td class="memItemLeft" align="right" valign="top">Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a423e2f2a67ccc0662a97e018b2c3886d">Status</a> () <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a423e2f2a67ccc0662a97e018b2c3886d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fdbd9a43d0168f1d6e6767aa89bb8d" id="r_ac8fdbd9a43d0168f1d6e6767aa89bb8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#ac8fdbd9a43d0168f1d6e6767aa89bb8d">NumVert</a> () <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:ac8fdbd9a43d0168f1d6e6767aa89bb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6358437d05a317c6bd0860f37ea20abf" id="r_a6358437d05a317c6bd0860f37ea20abf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a6358437d05a317c6bd0860f37ea20abf">NumEdge</a> () <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a6358437d05a317c6bd0860f37ea20abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa84bb817bb4f9b58ef22bdc62af686" id="r_aaaa84bb817bb4f9b58ef22bdc62af686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#aaaa84bb817bb4f9b58ef22bdc62af686">NumTri</a> () <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:aaaa84bb817bb4f9b58ef22bdc62af686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2851aefadd5cbee46c418ec6564e272f" id="r_a2851aefadd5cbee46c418ec6564e272f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a2851aefadd5cbee46c418ec6564e272f">NumProp</a> () <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a2851aefadd5cbee46c418ec6564e272f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35df8a9a52cf7dbd13265446d5993db9" id="r_a35df8a9a52cf7dbd13265446d5993db9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a35df8a9a52cf7dbd13265446d5993db9">NumPropVert</a> () <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a35df8a9a52cf7dbd13265446d5993db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d711d458596b520edd4cd7948a53e67" id="r_a3d711d458596b520edd4cd7948a53e67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a3d711d458596b520edd4cd7948a53e67">BoundingBox</a> () <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a3d711d458596b520edd4cd7948a53e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef800826805cb6d90d03846fdb12c3e3" id="r_aef800826805cb6d90d03846fdb12c3e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#aef800826805cb6d90d03846fdb12c3e3">Precision</a> () <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:aef800826805cb6d90d03846fdb12c3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1e9ca27fc618965d0bbbc9d29fb5c1" id="r_a4b1e9ca27fc618965d0bbbc9d29fb5c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a4b1e9ca27fc618965d0bbbc9d29fb5c1">Genus</a> () <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a4b1e9ca27fc618965d0bbbc9d29fb5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace809d84f44f59232653183bf86ece07" id="r_ace809d84f44f59232653183bf86ece07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemanifold.html#structmanifold_1_1_properties">Properties</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#ace809d84f44f59232653183bf86ece07">GetProperties</a> () <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:ace809d84f44f59232653183bf86ece07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7ab47f4da039eb3dff5b46ba71658b" id="r_a1b7ab47f4da039eb3dff5b46ba71658b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a1b7ab47f4da039eb3dff5b46ba71658b">MinGap</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;<a class="el" href="structmanifold_1_1_transform_iterator.html">other</a>, <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">searchLength</a>) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a1b7ab47f4da039eb3dff5b46ba71658b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Creation</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Constructors </p>
</td></tr>
<tr class="memitem:ad5f60691d05e3402630122740cdf3a0b" id="r_ad5f60691d05e3402630122740cdf3a0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#ad5f60691d05e3402630122740cdf3a0b">Manifold</a> ()</td></tr>
<tr class="separator:ad5f60691d05e3402630122740cdf3a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab50f8c59be50dc754ce516ee70f09a" id="r_a5ab50f8c59be50dc754ce516ee70f09a"><td class="memItemLeft" align="right" valign="top"><a id="a5ab50f8c59be50dc754ce516ee70f09a" name="a5ab50f8c59be50dc754ce516ee70f09a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Manifold</b> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;<a class="el" href="structmanifold_1_1_transform_iterator.html">other</a>)</td></tr>
<tr class="separator:a5ab50f8c59be50dc754ce516ee70f09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949bfe973d9de3e7218a823526dbd3c4" id="r_a949bfe973d9de3e7218a823526dbd3c4"><td class="memItemLeft" align="right" valign="top"><a id="a949bfe973d9de3e7218a823526dbd3c4" name="a949bfe973d9de3e7218a823526dbd3c4"></a>
<a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;<a class="el" href="structmanifold_1_1_transform_iterator.html">other</a>)</td></tr>
<tr class="separator:a949bfe973d9de3e7218a823526dbd3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b837703869ede405b8e8b250559cf3" id="r_af2b837703869ede405b8e8b250559cf3"><td class="memItemLeft" align="right" valign="top"><a id="af2b837703869ede405b8e8b250559cf3" name="af2b837703869ede405b8e8b250559cf3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Manifold</b> (<a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;&amp;) <a class="el" href="structmanifold_1_1_transform_iterator.html">noexcept</a></td></tr>
<tr class="separator:af2b837703869ede405b8e8b250559cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ade75fa137dd4788efb5a150222416" id="r_ac1ade75fa137dd4788efb5a150222416"><td class="memItemLeft" align="right" valign="top"><a id="ac1ade75fa137dd4788efb5a150222416" name="ac1ade75fa137dd4788efb5a150222416"></a>
<a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;&amp;) <a class="el" href="structmanifold_1_1_transform_iterator.html">noexcept</a></td></tr>
<tr class="separator:ac1ade75fa137dd4788efb5a150222416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbdc9ecbc563edb1fa67828c747b0ae" id="r_a7bbdc9ecbc563edb1fa67828c747b0ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a7bbdc9ecbc563edb1fa67828c747b0ae">Manifold</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="namespacemanifold.html#a4c4992743d3cf12ecd9f51b570a77a5f">MeshGL</a> &amp;)</td></tr>
<tr class="separator:a7bbdc9ecbc563edb1fa67828c747b0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5295e63030e90f0e138d8548ad4e87b5" id="r_a5295e63030e90f0e138d8548ad4e87b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a5295e63030e90f0e138d8548ad4e87b5">Manifold</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="structmanifold_1_1_mesh_g_l_p.html">MeshGL64</a> &amp;)</td></tr>
<tr class="separator:a5295e63030e90f0e138d8548ad4e87b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff03aac40d42a60f8e4254db90530c83" id="r_aff03aac40d42a60f8e4254db90530c83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">static</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#aff03aac40d42a60f8e4254db90530c83">Smooth</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="namespacemanifold.html#a4c4992743d3cf12ecd9f51b570a77a5f">MeshGL</a> &amp;, <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> std::vector&lt; <a class="el" href="namespacemanifold.html#structmanifold_1_1_smoothness">Smoothness</a> &gt; &amp;<a class="el" href="structmanifold_1_1_transform_iterator.html">sharpenedEdges</a>={})</td></tr>
<tr class="separator:aff03aac40d42a60f8e4254db90530c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65451c02a8868005e16804c1bb1d965d" id="r_a65451c02a8868005e16804c1bb1d965d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">static</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a65451c02a8868005e16804c1bb1d965d">Smooth</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="structmanifold_1_1_mesh_g_l_p.html">MeshGL64</a> &amp;, <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> std::vector&lt; <a class="el" href="namespacemanifold.html#structmanifold_1_1_smoothness">Smoothness</a> &gt; &amp;<a class="el" href="structmanifold_1_1_transform_iterator.html">sharpenedEdges</a>={})</td></tr>
<tr class="separator:a65451c02a8868005e16804c1bb1d965d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd42733f05fb87dec1b3dae9ff9f582" id="r_afbd42733f05fb87dec1b3dae9ff9f582"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">static</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#afbd42733f05fb87dec1b3dae9ff9f582">Tetrahedron</a> ()</td></tr>
<tr class="separator:afbd42733f05fb87dec1b3dae9ff9f582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5486e9d0cff020565c3c20c1f496ab9" id="r_ad5486e9d0cff020565c3c20c1f496ab9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">static</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#ad5486e9d0cff020565c3c20c1f496ab9">Cube</a> (vec3 size=vec3(1.0), <a class="el" href="structmanifold_1_1_transform_iterator.html">bool</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">center</a>=<a class="el" href="structmanifold_1_1_transform_iterator.html">false</a>)</td></tr>
<tr class="separator:ad5486e9d0cff020565c3c20c1f496ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879b867522c562c7166af539894a2815" id="r_a879b867522c562c7166af539894a2815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">static</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a879b867522c562c7166af539894a2815">Cylinder</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">height</a>, <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">radiusLow</a>, <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">radiusHigh</a>=-1.0, <a class="el" href="structmanifold_1_1_transform_iterator.html">int</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">circularSegments</a>=0, <a class="el" href="structmanifold_1_1_transform_iterator.html">bool</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">center</a>=<a class="el" href="structmanifold_1_1_transform_iterator.html">false</a>)</td></tr>
<tr class="separator:a879b867522c562c7166af539894a2815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606301a59534ef00a89dc7d7a132abe6" id="r_a606301a59534ef00a89dc7d7a132abe6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">static</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a606301a59534ef00a89dc7d7a132abe6">Sphere</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">radius</a>, <a class="el" href="structmanifold_1_1_transform_iterator.html">int</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">circularSegments</a>=0)</td></tr>
<tr class="separator:a606301a59534ef00a89dc7d7a132abe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37da082109050d748421069e22eff876" id="r_a37da082109050d748421069e22eff876"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">static</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a37da082109050d748421069e22eff876">Extrude</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="namespacemanifold.html#a60a66d8ddacc086bb45d8afc37f646d1">Polygons</a> &amp;<a class="el" href="structmanifold_1_1_transform_iterator.html">crossSection</a>, <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">height</a>, <a class="el" href="structmanifold_1_1_transform_iterator.html">int</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">nDivisions</a>=0, <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">twistDegrees</a>=0.0, vec2 <a class="el" href="structmanifold_1_1_transform_iterator.html">scaleTop</a>=vec2(1.0))</td></tr>
<tr class="separator:a37da082109050d748421069e22eff876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c454a293abbf86f520e10266087f5a6" id="r_a8c454a293abbf86f520e10266087f5a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">static</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a8c454a293abbf86f520e10266087f5a6">Revolve</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="namespacemanifold.html#a60a66d8ddacc086bb45d8afc37f646d1">Polygons</a> &amp;<a class="el" href="structmanifold_1_1_transform_iterator.html">crossSection</a>, <a class="el" href="structmanifold_1_1_transform_iterator.html">int</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">circularSegments</a>=0, <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">revolveDegrees</a>=360.0f)</td></tr>
<tr class="separator:a8c454a293abbf86f520e10266087f5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga359e374df5225fef63061f32718e2fb3" id="r_ga359e374df5225fef63061f32718e2fb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">static</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___core.html#ga359e374df5225fef63061f32718e2fb3">LevelSet</a> (std::function&lt; <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>(vec3)&gt; sdf, <a class="el" href="structmanifold_1_1_box.html">Box</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">bounds</a>, <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">edgeLength</a>, <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> level=0, <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> precision=-1, <a class="el" href="structmanifold_1_1_transform_iterator.html">bool</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">canParallel</a>=<a class="el" href="structmanifold_1_1_transform_iterator.html">true</a>)</td></tr>
<tr class="separator:ga359e374df5225fef63061f32718e2fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Topological</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>No geometric calculations. </p>
</td></tr>
<tr class="memitem:a7f20b130779680156ce0d28d91e5d106" id="r_a7f20b130779680156ce0d28d91e5d106"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a7f20b130779680156ce0d28d91e5d106">Decompose</a> () <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a7f20b130779680156ce0d28d91e5d106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a1b20e25443713304db55196573e3d" id="r_a96a1b20e25443713304db55196573e3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">static</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a96a1b20e25443713304db55196573e3d">Compose</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> std::vector&lt; <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &gt; &amp;)</td></tr>
<tr class="separator:a96a1b20e25443713304db55196573e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Mesh ID</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Details of the manifold's relation to its input meshes, for the purposes of reapplying mesh properties. </p>
</td></tr>
<tr class="memitem:a65b3ff79efc694738a4f56270cc608e6" id="r_a65b3ff79efc694738a4f56270cc608e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a65b3ff79efc694738a4f56270cc608e6">OriginalID</a> () <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a65b3ff79efc694738a4f56270cc608e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b19c952fea13377208697971dc26ec" id="r_aa2b19c952fea13377208697971dc26ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#aa2b19c952fea13377208697971dc26ec">AsOriginal</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> std::vector&lt; <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> &gt; &amp;<a class="el" href="structmanifold_1_1_transform_iterator.html">propertyTolerance</a>={}) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:aa2b19c952fea13377208697971dc26ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7e7e674ce7bd9954dc0d54ec6ebc8c" id="r_a1d7e7e674ce7bd9954dc0d54ec6ebc8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">static</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a1d7e7e674ce7bd9954dc0d54ec6ebc8c">ReserveIDs</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">uint32_t</a>)</td></tr>
<tr class="separator:a1d7e7e674ce7bd9954dc0d54ec6ebc8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Modification</h2></td></tr>
<tr class="memitem:a78fbea69555ea755f8731255060f7c9d" id="r_a78fbea69555ea755f8731255060f7c9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a78fbea69555ea755f8731255060f7c9d">Translate</a> (vec3) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a78fbea69555ea755f8731255060f7c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6153eb69d3a69e38e6508bf58449f04" id="r_aa6153eb69d3a69e38e6508bf58449f04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#aa6153eb69d3a69e38e6508bf58449f04">Scale</a> (vec3) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:aa6153eb69d3a69e38e6508bf58449f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f74bf3b7c5dd34e84b82e7738fd25ff" id="r_a7f74bf3b7c5dd34e84b82e7738fd25ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a7f74bf3b7c5dd34e84b82e7738fd25ff">Rotate</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">xDegrees</a>, <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">yDegrees</a>=0.0, <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">zDegrees</a>=0.0) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a7f74bf3b7c5dd34e84b82e7738fd25ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4459c0e7355b2805b2694da075c8346" id="r_af4459c0e7355b2805b2694da075c8346"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#af4459c0e7355b2805b2694da075c8346">Transform</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> mat4x3 &amp;) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:af4459c0e7355b2805b2694da075c8346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76d89178ca970900c81f2927f8c7f11" id="r_ad76d89178ca970900c81f2927f8c7f11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#ad76d89178ca970900c81f2927f8c7f11">Mirror</a> (vec3) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:ad76d89178ca970900c81f2927f8c7f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5366f7082adcbb2be63fcf2b4c57eb51" id="r_a5366f7082adcbb2be63fcf2b4c57eb51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a5366f7082adcbb2be63fcf2b4c57eb51">Warp</a> (std::function&lt; <a class="el" href="structmanifold_1_1_transform_iterator.html">void</a>(vec3 &amp;)&gt;) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a5366f7082adcbb2be63fcf2b4c57eb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7825d52e3102cc6e7d48a19f9ea0b468" id="r_a7825d52e3102cc6e7d48a19f9ea0b468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a7825d52e3102cc6e7d48a19f9ea0b468">WarpBatch</a> (std::function&lt; <a class="el" href="structmanifold_1_1_transform_iterator.html">void</a>(<a class="el" href="classmanifold_1_1_vec_view.html">VecView</a>&lt; vec3 &gt;)&gt;) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a7825d52e3102cc6e7d48a19f9ea0b468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a852721876d6fce2136ac27e7377f8e" id="r_a6a852721876d6fce2136ac27e7377f8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a6a852721876d6fce2136ac27e7377f8e">SetProperties</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">int</a>, std::function&lt; <a class="el" href="structmanifold_1_1_transform_iterator.html">void</a>(<a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> *, vec3, <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> *)&gt;) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a6a852721876d6fce2136ac27e7377f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19abb297f7b7b43f5c84562bcc7df705" id="r_a19abb297f7b7b43f5c84562bcc7df705"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a19abb297f7b7b43f5c84562bcc7df705">CalculateCurvature</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">int</a> gaussianIdx, <a class="el" href="structmanifold_1_1_transform_iterator.html">int</a> meanIdx) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a19abb297f7b7b43f5c84562bcc7df705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c0e49ed98c9c03bc1324d4ff8452ce" id="r_ab6c0e49ed98c9c03bc1324d4ff8452ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#ab6c0e49ed98c9c03bc1324d4ff8452ce">CalculateNormals</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">int</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">normalIdx</a>, <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">minSharpAngle</a>=60) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:ab6c0e49ed98c9c03bc1324d4ff8452ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cbb9710c375f40591c3ae2dd62f2b4" id="r_aa0cbb9710c375f40591c3ae2dd62f2b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#aa0cbb9710c375f40591c3ae2dd62f2b4">SmoothByNormals</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">int</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">normalIdx</a>) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:aa0cbb9710c375f40591c3ae2dd62f2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b59680c4bc2300e0e12713ab220d3d5" id="r_a0b59680c4bc2300e0e12713ab220d3d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a0b59680c4bc2300e0e12713ab220d3d5">SmoothOut</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">minSharpAngle</a>=60, <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">minSmoothness</a>=0) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a0b59680c4bc2300e0e12713ab220d3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9227a2d10d8ad7b005555213ecd1ac" id="r_a5d9227a2d10d8ad7b005555213ecd1ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a5d9227a2d10d8ad7b005555213ecd1ac">Refine</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">int</a>) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a5d9227a2d10d8ad7b005555213ecd1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1381728e52975862d954032f717106d5" id="r_a1381728e52975862d954032f717106d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a1381728e52975862d954032f717106d5">RefineToLength</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a1381728e52975862d954032f717106d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c458bbdad94b7445158f0f2d4cdb62c" id="r_a6c458bbdad94b7445158f0f2d4cdb62c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a6c458bbdad94b7445158f0f2d4cdb62c">RefineToPrecision</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a6c458bbdad94b7445158f0f2d4cdb62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Boolean</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Combine two manifolds </p>
</td></tr>
<tr class="memitem:a9aad9d9b9a58ff2b7622de673742d1df" id="r_a9aad9d9b9a58ff2b7622de673742d1df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a9aad9d9b9a58ff2b7622de673742d1df">Boolean</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;second, <a class="el" href="group___core.html#gaa1aa1c6a8f3bbed5b167bc2d4511b969">OpType</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">op</a>) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a9aad9d9b9a58ff2b7622de673742d1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95e73e5427d09b9d9e025d5cf367c30" id="r_af95e73e5427d09b9d9e025d5cf367c30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#af95e73e5427d09b9d9e025d5cf367c30">operator+</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:af95e73e5427d09b9d9e025d5cf367c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530ec6ae990090f4b5c52f0d32eb2688" id="r_a530ec6ae990090f4b5c52f0d32eb2688"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a530ec6ae990090f4b5c52f0d32eb2688">operator+=</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;)</td></tr>
<tr class="separator:a530ec6ae990090f4b5c52f0d32eb2688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9da8c505e6846e9645008825833e1da" id="r_ad9da8c505e6846e9645008825833e1da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#ad9da8c505e6846e9645008825833e1da">operator-</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:ad9da8c505e6846e9645008825833e1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17823c1f0efdfa41324892e52ab1f2b" id="r_ae17823c1f0efdfa41324892e52ab1f2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#ae17823c1f0efdfa41324892e52ab1f2b">operator-=</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;)</td></tr>
<tr class="separator:ae17823c1f0efdfa41324892e52ab1f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e4e5720f01934c44aebc597be4d104" id="r_ad1e4e5720f01934c44aebc597be4d104"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#ad1e4e5720f01934c44aebc597be4d104">operator^</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:ad1e4e5720f01934c44aebc597be4d104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88768bbf9fabf89e72b27a45321b6522" id="r_a88768bbf9fabf89e72b27a45321b6522"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a88768bbf9fabf89e72b27a45321b6522">operator^=</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;)</td></tr>
<tr class="separator:a88768bbf9fabf89e72b27a45321b6522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e241b8a56d334b3d2d3dbd2fc808ba" id="r_a60e241b8a56d334b3d2d3dbd2fc808ba"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>, <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a60e241b8a56d334b3d2d3dbd2fc808ba">Split</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a60e241b8a56d334b3d2d3dbd2fc808ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c2716b965886e4fb952e5ade866a5a" id="r_a40c2716b965886e4fb952e5ade866a5a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>, <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a40c2716b965886e4fb952e5ade866a5a">SplitByPlane</a> (vec3 <a class="el" href="structmanifold_1_1_transform_iterator.html">normal</a>, <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">originOffset</a>) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a40c2716b965886e4fb952e5ade866a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d62161da6e94da7651418c33c3e294" id="r_aa8d62161da6e94da7651418c33c3e294"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#aa8d62161da6e94da7651418c33c3e294">TrimByPlane</a> (vec3 <a class="el" href="structmanifold_1_1_transform_iterator.html">normal</a>, <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">originOffset</a>) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:aa8d62161da6e94da7651418c33c3e294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b30c42e224bda7e71a3ed3cf02319c1" id="r_a1b30c42e224bda7e71a3ed3cf02319c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">static</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a1b30c42e224bda7e71a3ed3cf02319c1">BatchBoolean</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> std::vector&lt; <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &gt; &amp;<a class="el" href="structmanifold_1_1_transform_iterator.html">manifolds</a>, <a class="el" href="group___core.html#gaa1aa1c6a8f3bbed5b167bc2d4511b969">OpType</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">op</a>)</td></tr>
<tr class="separator:a1b30c42e224bda7e71a3ed3cf02319c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">2D from 3D</h2></td></tr>
<tr class="memitem:ad03837de2290a269fa14e0773c9913fa" id="r_ad03837de2290a269fa14e0773c9913fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemanifold.html#a60a66d8ddacc086bb45d8afc37f646d1">Polygons</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#ad03837de2290a269fa14e0773c9913fa">Slice</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">height</a>=0) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:ad03837de2290a269fa14e0773c9913fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328657b69e9bbaaee148572ca314677c" id="r_a328657b69e9bbaaee148572ca314677c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemanifold.html#a60a66d8ddacc086bb45d8afc37f646d1">Polygons</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a328657b69e9bbaaee148572ca314677c">Project</a> () <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a328657b69e9bbaaee148572ca314677c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Convex hull</h2></td></tr>
<tr class="memitem:a9dc9e00112e2b063cfa6fe8482b1afe8" id="r_a9dc9e00112e2b063cfa6fe8482b1afe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a9dc9e00112e2b063cfa6fe8482b1afe8">Hull</a> () <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a9dc9e00112e2b063cfa6fe8482b1afe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b45afc24015963e82745f1f83f3f310" id="r_a0b45afc24015963e82745f1f83f3f310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">static</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a0b45afc24015963e82745f1f83f3f310">Hull</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> std::vector&lt; <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &gt; &amp;<a class="el" href="structmanifold_1_1_transform_iterator.html">manifolds</a>)</td></tr>
<tr class="separator:a0b45afc24015963e82745f1f83f3f310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a6fa5c97e3e47118ee69b741e64ad0" id="r_ab0a6fa5c97e3e47118ee69b741e64ad0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">static</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#ab0a6fa5c97e3e47118ee69b741e64ad0">Hull</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> std::vector&lt; vec3 &gt; &amp;<a class="el" href="structmanifold_1_1_transform_iterator.html">pts</a>)</td></tr>
<tr class="separator:ab0a6fa5c97e3e47118ee69b741e64ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Testing hooks</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>These are just for internal testing. </p>
</td></tr>
<tr class="memitem:a611a5fd95dc5d49cd88182b8ead722b7" id="r_a611a5fd95dc5d49cd88182b8ead722b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a611a5fd95dc5d49cd88182b8ead722b7">MatchesTriNormals</a> () <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a611a5fd95dc5d49cd88182b8ead722b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46a22b8e84924f7159ae2a2db6cc956" id="r_af46a22b8e84924f7159ae2a2db6cc956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#af46a22b8e84924f7159ae2a2db6cc956">NumDegenerateTris</a> () <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:af46a22b8e84924f7159ae2a2db6cc956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f15752f22381625ec9f04e1488fc69" id="r_a83f15752f22381625ec9f04e1488fc69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmanifold_1_1_transform_iterator.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmanifold_1_1_manifold.html#a83f15752f22381625ec9f04e1488fc69">NumOverlaps</a> (<a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;second) <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a></td></tr>
<tr class="separator:a83f15752f22381625ec9f04e1488fc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This library's internal representation of an oriented, 2-manifold, triangle mesh - a simple boundary-representation of a solid object. Use this class to store and operate on solids, and use MeshGL for input and output, or potentially Mesh if only basic geometry is required.</p>
<p>In addition to storing geometric data, a <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> can also store an arbitrary number of vertex properties. These could be anything, e.g. normals, UV coordinates, colors, etc, but this library is completely agnostic. All properties are merely float values indexed by channel number. It is up to the user to associate channel numbers with meaning.</p>
<p><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> allows vertex properties to be shared for efficient storage, or to have multiple property verts associated with a single geometric vertex, allowing sudden property changes, e.g. at Boolean intersections, without sacrificing manifoldness.</p>
<p>Manifolds also keep track of their relationships to their inputs, via OriginalIDs and the faceIDs and transforms accessible through MeshGL. This allows object-level properties to be re-associated with the output after many operations, particularly useful for materials. Since separate object's properties are not mixed, there is no requirement that channels have consistent meaning between different inputs. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad5f60691d05e3402630122740cdf3a0b" name="ad5f60691d05e3402630122740cdf3a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f60691d05e3402630122740cdf3a0b">&#9670;&#160;</a></span>Manifold() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an empty <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>. </p>

</div>
</div>
<a id="a7bbdc9ecbc563edb1fa67828c747b0ae" name="a7bbdc9ecbc563edb1fa67828c747b0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbdc9ecbc563edb1fa67828c747b0ae">&#9670;&#160;</a></span>Manifold() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="namespacemanifold.html#a4c4992743d3cf12ecd9f51b570a77a5f">MeshGL</a> &amp;&#160;</td>
          <td class="paramname"><em>meshGL</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a MeshGL into a <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>, retaining its properties and merging only the positions according to the merge vectors. Will return an empty <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> and set an Error Status if the result is not an oriented 2-manifold. Will collapse degenerate triangles and unnecessary vertices.</p>
<p>All fields are read, making this structure suitable for a lossless round-trip of data from GetMeshGL. For multi-material input, use ReserveIDs to set a unique originalID for each material, and sort the materials into triangle runs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshGL</td><td>The input MeshGL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5295e63030e90f0e138d8548ad4e87b5" name="a5295e63030e90f0e138d8548ad4e87b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5295e63030e90f0e138d8548ad4e87b5">&#9670;&#160;</a></span>Manifold() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="structmanifold_1_1_mesh_g_l_p.html">MeshGL64</a> &amp;&#160;</td>
          <td class="paramname"><em>meshGL64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a MeshGL into a <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>, retaining its properties and merging only the positions according to the merge vectors. Will return an empty <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> and set an Error Status if the result is not an oriented 2-manifold. Will collapse degenerate triangles and unnecessary vertices.</p>
<p>All fields are read, making this structure suitable for a lossless round-trip of data from GetMeshGL. For multi-material input, use ReserveIDs to set a unique originalID for each material, and sort the materials into triangle runs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshGL</td><td>The input MeshGL. </td></tr>
    <tr><td class="paramname">propertyTolerance</td><td>A vector of precision values for each property beyond position. If specified, the propertyTolerance vector must have size = numProp - 3. This is the amount of interpolation error allowed before two neighboring triangles are considered to be on a property boundary edge. Property boundary edges will be retained across operations even if the triangles are coplanar. Defaults to 1e-5, which works well for most properties in the [-1, 1] range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aff03aac40d42a60f8e4254db90530c83" name="aff03aac40d42a60f8e4254db90530c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff03aac40d42a60f8e4254db90530c83">&#9670;&#160;</a></span>Smooth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Smooth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="namespacemanifold.html#a4c4992743d3cf12ecd9f51b570a77a5f">MeshGL</a> &amp;&#160;</td>
          <td class="paramname"><em>meshGL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> std::vector&lt; <a class="el" href="namespacemanifold.html#structmanifold_1_1_smoothness">Smoothness</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sharpenedEdges</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a smooth version of the input mesh by creating tangents; this method will throw if you have supplied tangents with your mesh already. The actual triangle resolution is unchanged; use the <a class="el" href="classmanifold_1_1_manifold.html#a5d9227a2d10d8ad7b005555213ecd1ac">Refine()</a> method to interpolate to a higher-resolution curve.</p>
<p>By default, every edge is calculated for maximum smoothness (very much approximately), attempting to minimize the maximum mean Curvature magnitude. No higher-order derivatives are considered, as the interpolation is independent per triangle, only sharing constraints on their boundaries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshGL</td><td>input MeshGL. </td></tr>
    <tr><td class="paramname">sharpenedEdges</td><td>If desired, you can supply a vector of sharpened halfedges, which should in general be a small subset of all halfedges. Order of entries doesn't matter, as each one specifies the desired smoothness (between zero and one, with one the default for all unspecified halfedges) and the halfedge index (3 * triangle index + [0,1,2] where 0 is the edge between triVert 0 and 1, etc).</td></tr>
  </table>
  </dd>
</dl>
<p>At a smoothness value of zero, a sharp crease is made. The smoothness is interpolated along each edge, so the specified value should be thought of as an average. Where exactly two sharpened edges meet at a vertex, their tangents are rotated to be colinear so that the sharpened edge can be continuous. Vertices with only one sharpened edge are completely smooth, allowing sharpened edges to smoothly vanish at termination. A single vertex can be sharpened by sharping all edges that are incident on it, allowing cones to be formed. </p>

</div>
</div>
<a id="a65451c02a8868005e16804c1bb1d965d" name="a65451c02a8868005e16804c1bb1d965d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65451c02a8868005e16804c1bb1d965d">&#9670;&#160;</a></span>Smooth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Smooth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="structmanifold_1_1_mesh_g_l_p.html">MeshGL64</a> &amp;&#160;</td>
          <td class="paramname"><em>meshGL64</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> std::vector&lt; <a class="el" href="namespacemanifold.html#structmanifold_1_1_smoothness">Smoothness</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sharpenedEdges</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a smooth version of the input mesh by creating tangents; this method will throw if you have supplied tangents with your mesh already. The actual triangle resolution is unchanged; use the <a class="el" href="classmanifold_1_1_manifold.html#a5d9227a2d10d8ad7b005555213ecd1ac">Refine()</a> method to interpolate to a higher-resolution curve.</p>
<p>By default, every edge is calculated for maximum smoothness (very much approximately), attempting to minimize the maximum mean Curvature magnitude. No higher-order derivatives are considered, as the interpolation is independent per triangle, only sharing constraints on their boundaries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshGL</td><td>input MeshGL. </td></tr>
    <tr><td class="paramname">sharpenedEdges</td><td>If desired, you can supply a vector of sharpened halfedges, which should in general be a small subset of all halfedges. Order of entries doesn't matter, as each one specifies the desired smoothness (between zero and one, with one the default for all unspecified halfedges) and the halfedge index (3 * triangle index + [0,1,2] where 0 is the edge between triVert 0 and 1, etc).</td></tr>
  </table>
  </dd>
</dl>
<p>At a smoothness value of zero, a sharp crease is made. The smoothness is interpolated along each edge, so the specified value should be thought of as an average. Where exactly two sharpened edges meet at a vertex, their tangents are rotated to be colinear so that the sharpened edge can be continuous. Vertices with only one sharpened edge are completely smooth, allowing sharpened edges to smoothly vanish at termination. A single vertex can be sharpened by sharping all edges that are incident on it, allowing cones to be formed. </p>

</div>
</div>
<a id="afbd42733f05fb87dec1b3dae9ff9f582" name="afbd42733f05fb87dec1b3dae9ff9f582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd42733f05fb87dec1b3dae9ff9f582">&#9670;&#160;</a></span>Tetrahedron()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Tetrahedron </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a tetrahedron centered at the origin with one vertex at (1,1,1) and the rest at similarly symmetric points. </p>

</div>
</div>
<a id="ad5486e9d0cff020565c3c20c1f496ab9" name="ad5486e9d0cff020565c3c20c1f496ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5486e9d0cff020565c3c20c1f496ab9">&#9670;&#160;</a></span>Cube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Cube </td>
          <td>(</td>
          <td class="paramtype">vec3&#160;</td>
          <td class="paramname"><em>size</em> = <code>vec3(1.0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">bool</a>&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="structmanifold_1_1_transform_iterator.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a unit cube (edge lengths all one), by default in the first octant, touching the origin. If any dimensions in size are negative, or if all are zero, an empty <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The X, Y, and Z dimensions of the box. </td></tr>
    <tr><td class="paramname">center</td><td>Set to true to shift the center to the origin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a879b867522c562c7166af539894a2815" name="a879b867522c562c7166af539894a2815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879b867522c562c7166af539894a2815">&#9670;&#160;</a></span>Cylinder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Cylinder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>radiusLow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>radiusHigh</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">int</a>&#160;</td>
          <td class="paramname"><em>circularSegments</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">bool</a>&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="structmanifold_1_1_transform_iterator.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A convenience constructor for the common case of extruding a circle. Can also form cones if both radii are specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>Z-extent </td></tr>
    <tr><td class="paramname">radiusLow</td><td>Radius of bottom circle. Must be positive. </td></tr>
    <tr><td class="paramname">radiusHigh</td><td>Radius of top circle. Can equal zero. Default is equal to radiusLow. </td></tr>
    <tr><td class="paramname">circularSegments</td><td>How many line segments to use around the circle. Default is calculated by the static Defaults. </td></tr>
    <tr><td class="paramname">center</td><td>Set to true to shift the center to the origin. Default is origin at the bottom. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a606301a59534ef00a89dc7d7a132abe6" name="a606301a59534ef00a89dc7d7a132abe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606301a59534ef00a89dc7d7a132abe6">&#9670;&#160;</a></span>Sphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Sphere </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">int</a>&#160;</td>
          <td class="paramname"><em>circularSegments</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a geodesic sphere of a given radius.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>Radius of the sphere. Must be positive. </td></tr>
    <tr><td class="paramname">circularSegments</td><td>Number of segments along its diameter. This number will always be rounded up to the nearest factor of four, as this sphere is constructed by refining an octahedron. This means there are a circle of vertices on all three of the axis planes. Default is calculated by the static Defaults. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37da082109050d748421069e22eff876" name="a37da082109050d748421069e22eff876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37da082109050d748421069e22eff876">&#9670;&#160;</a></span>Extrude()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Extrude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="namespacemanifold.html#a60a66d8ddacc086bb45d8afc37f646d1">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>crossSection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">int</a>&#160;</td>
          <td class="paramname"><em>nDivisions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>twistDegrees</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec2&#160;</td>
          <td class="paramname"><em>scaleTop</em> = <code>vec2(1.0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a manifold from a set of polygons by extruding them along the Z-axis. Note that high twistDegrees with small nDivisions may cause self-intersection. This is not checked here and it is up to the user to choose the correct parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossSection</td><td>A set of non-overlapping polygons to extrude. </td></tr>
    <tr><td class="paramname">height</td><td>Z-extent of extrusion. </td></tr>
    <tr><td class="paramname">nDivisions</td><td>Number of extra copies of the crossSection to insert into the shape vertically; especially useful in combination with twistDegrees to avoid interpolation artifacts. Default is none. </td></tr>
    <tr><td class="paramname">twistDegrees</td><td>Amount to twist the top crossSection relative to the bottom, interpolated linearly for the divisions in between. </td></tr>
    <tr><td class="paramname">scaleTop</td><td>Amount to scale the top (independently in X and Y). If the scale is {0, 0}, a pure cone is formed with only a single vertex at the top. Note that scale is applied after twist. Default {1, 1}. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c454a293abbf86f520e10266087f5a6" name="a8c454a293abbf86f520e10266087f5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c454a293abbf86f520e10266087f5a6">&#9670;&#160;</a></span>Revolve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Revolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="namespacemanifold.html#a60a66d8ddacc086bb45d8afc37f646d1">Polygons</a> &amp;&#160;</td>
          <td class="paramname"><em>crossSection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">int</a>&#160;</td>
          <td class="paramname"><em>circularSegments</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>revolveDegrees</em> = <code>360.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a manifold from a set of polygons by revolving this cross-section around its Y-axis and then setting this as the Z-axis of the resulting manifold. If the polygons cross the Y-axis, only the part on the positive X side is used. Geometrically valid input will result in geometrically valid output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossSection</td><td>A set of non-overlapping polygons to revolve. </td></tr>
    <tr><td class="paramname">circularSegments</td><td>Number of segments along its diameter. Default is calculated by the static Defaults. </td></tr>
    <tr><td class="paramname">revolveDegrees</td><td>Number of degrees to revolve. Default is 360 degrees. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96a1b20e25443713304db55196573e3d" name="a96a1b20e25443713304db55196573e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a1b20e25443713304db55196573e3d">&#9670;&#160;</a></span>Compose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Compose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> std::vector&lt; <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>manifolds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a new manifold from a vector of other manifolds. This is a purely topological operation, so care should be taken to avoid creating overlapping results. It is the inverse operation of <a class="el" href="classmanifold_1_1_manifold.html#a7f20b130779680156ce0d28d91e5d106">Decompose()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manifolds</td><td>A vector of Manifolds to lazy-union together. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f20b130779680156ce0d28d91e5d106" name="a7f20b130779680156ce0d28d91e5d106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f20b130779680156ce0d28d91e5d106">&#9670;&#160;</a></span>Decompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &gt; Decompose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This operation returns a vector of Manifolds that are topologically disconnected. If everything is connected, the vector is length one, containing a copy of the original. It is the inverse operation of <a class="el" href="classmanifold_1_1_manifold.html#a96a1b20e25443713304db55196573e3d">Compose()</a>. </p>

</div>
</div>
<a id="a3711c029f2c9fe2d152455981a3b2d73" name="a3711c029f2c9fe2d152455981a3b2d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3711c029f2c9fe2d152455981a3b2d73">&#9670;&#160;</a></span>GetMeshGL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemanifold.html#a4c4992743d3cf12ecd9f51b570a77a5f">MeshGL</a> GetMeshGL </td>
          <td>(</td>
          <td class="paramtype">ivec3&#160;</td>
          <td class="paramname"><em>normalIdx</em> = <code>ivec3(0)</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The most complete output of this library, returning a MeshGL that is designed to easily push into a renderer, including all interleaved vertex properties that may have been input. It also includes relations to all the input meshes that form a part of this result and the transforms applied to each.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normalIdx</td><td>If the original MeshGL inputs that formed this manifold had properties corresponding to normal vectors, you can specify which property channels these are (x, y, z), which will cause this output MeshGL to automatically update these normals according to the applied transforms and front/back side. Each channel must be &gt;= 3 and &lt; numProp, and all original MeshGLs must use the same channels for their normals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf81b50cc39e7280e80cb8bf173e98bb" name="aaf81b50cc39e7280e80cb8bf173e98bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf81b50cc39e7280e80cb8bf173e98bb">&#9670;&#160;</a></span>GetMeshGL64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmanifold_1_1_mesh_g_l_p.html">MeshGL64</a> GetMeshGL64 </td>
          <td>(</td>
          <td class="paramtype">ivec3&#160;</td>
          <td class="paramname"><em>normalIdx</em> = <code>ivec3(0)</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The most complete output of this library, returning a MeshGL that is designed to easily push into a renderer, including all interleaved vertex properties that may have been input. It also includes relations to all the input meshes that form a part of this result and the transforms applied to each.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normalIdx</td><td>If the original MeshGL inputs that formed this manifold had properties corresponding to normal vectors, you can specify which property channels these are (x, y, z), which will cause this output MeshGL to automatically update these normals according to the applied transforms and front/back side. Each channel must be &gt;= 3 and &lt; numProp, and all original MeshGLs must use the same channels for their normals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e12342fc420701fbffd97025421575a" name="a8e12342fc420701fbffd97025421575a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e12342fc420701fbffd97025421575a">&#9670;&#160;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmanifold_1_1_transform_iterator.html">bool</a> IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does the <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> have any triangles? </p>

</div>
</div>
<a id="a423e2f2a67ccc0662a97e018b2c3886d" name="a423e2f2a67ccc0662a97e018b2c3886d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423e2f2a67ccc0662a97e018b2c3886d">&#9670;&#160;</a></span>Status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Manifold::Error Status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the reason for an input Mesh producing an empty <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>. This Status only applies to Manifolds newly-created from an input Mesh - once they are combined into a new <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> via operations, the status reverts to NoError, simply processing the problem mesh as empty. Likewise, empty meshes may still show NoError, for instance if they are small enough relative to their precision to be collapsed to nothing. </p>

</div>
</div>
<a id="ac8fdbd9a43d0168f1d6e6767aa89bb8d" name="ac8fdbd9a43d0168f1d6e6767aa89bb8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8fdbd9a43d0168f1d6e6767aa89bb8d">&#9670;&#160;</a></span>NumVert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmanifold_1_1_transform_iterator.html">size_t</a> NumVert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of vertices in the <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>. </p>

</div>
</div>
<a id="a6358437d05a317c6bd0860f37ea20abf" name="a6358437d05a317c6bd0860f37ea20abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6358437d05a317c6bd0860f37ea20abf">&#9670;&#160;</a></span>NumEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmanifold_1_1_transform_iterator.html">size_t</a> NumEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of edges in the <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>. </p>

</div>
</div>
<a id="aaaa84bb817bb4f9b58ef22bdc62af686" name="aaaa84bb817bb4f9b58ef22bdc62af686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa84bb817bb4f9b58ef22bdc62af686">&#9670;&#160;</a></span>NumTri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmanifold_1_1_transform_iterator.html">size_t</a> NumTri </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of triangles in the <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>. </p>

</div>
</div>
<a id="a2851aefadd5cbee46c418ec6564e272f" name="a2851aefadd5cbee46c418ec6564e272f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2851aefadd5cbee46c418ec6564e272f">&#9670;&#160;</a></span>NumProp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmanifold_1_1_transform_iterator.html">size_t</a> NumProp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of properties per vertex in the <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>. </p>

</div>
</div>
<a id="a35df8a9a52cf7dbd13265446d5993db9" name="a35df8a9a52cf7dbd13265446d5993db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35df8a9a52cf7dbd13265446d5993db9">&#9670;&#160;</a></span>NumPropVert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmanifold_1_1_transform_iterator.html">size_t</a> NumPropVert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of property vertices in the <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>. This will always be &gt;= NumVert, as some physical vertices may be duplicated to account for different properties on different neighboring triangles. </p>

</div>
</div>
<a id="a3d711d458596b520edd4cd7948a53e67" name="a3d711d458596b520edd4cd7948a53e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d711d458596b520edd4cd7948a53e67">&#9670;&#160;</a></span>BoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmanifold_1_1_box.html">Box</a> BoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the axis-aligned bounding box of all the <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>'s vertices. </p>

</div>
</div>
<a id="aef800826805cb6d90d03846fdb12c3e3" name="aef800826805cb6d90d03846fdb12c3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef800826805cb6d90d03846fdb12c3e3">&#9670;&#160;</a></span>Precision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> Precision </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the precision of this <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>'s vertices, which tracks the approximate rounding error over all the transforms and operations that have led to this state. Any triangles that are colinear within this precision are considered degenerate and removed. This is the value of &epsilon; defining <a href="https://github.com/elalish/manifold/wiki/Manifold-Library#definition-of-%CE%B5-valid">&epsilon;-valid</a>. </p>

</div>
</div>
<a id="a4b1e9ca27fc618965d0bbbc9d29fb5c1" name="a4b1e9ca27fc618965d0bbbc9d29fb5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1e9ca27fc618965d0bbbc9d29fb5c1">&#9670;&#160;</a></span>Genus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmanifold_1_1_transform_iterator.html">int</a> Genus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The genus is a topological property of the manifold, representing the number of "handles". A sphere is 0, torus 1, etc. It is only meaningful for a single mesh, so it is best to call <a class="el" href="classmanifold_1_1_manifold.html#a7f20b130779680156ce0d28d91e5d106">Decompose()</a> first. </p>

</div>
</div>
<a id="ace809d84f44f59232653183bf86ece07" name="ace809d84f44f59232653183bf86ece07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace809d84f44f59232653183bf86ece07">&#9670;&#160;</a></span>GetProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemanifold.html#structmanifold_1_1_properties">Properties</a> GetProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the surface area and volume of the manifold. </p>

</div>
</div>
<a id="a1b7ab47f4da039eb3dff5b46ba71658b" name="a1b7ab47f4da039eb3dff5b46ba71658b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7ab47f4da039eb3dff5b46ba71658b">&#9670;&#160;</a></span>MinGap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> MinGap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>searchLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the minimum gap between two manifolds. Returns a double between 0 and searchLength.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other manifold to compute the minimum gap to. </td></tr>
    <tr><td class="paramname">searchLength</td><td>The maximum distance to search for a minimum gap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65b3ff79efc694738a4f56270cc608e6" name="a65b3ff79efc694738a4f56270cc608e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b3ff79efc694738a4f56270cc608e6">&#9670;&#160;</a></span>OriginalID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmanifold_1_1_transform_iterator.html">int</a> OriginalID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this mesh is an original, this returns its meshID that can be referenced by product manifolds' MeshRelation. If this manifold is a product, this returns -1. </p>

</div>
</div>
<a id="aa2b19c952fea13377208697971dc26ec" name="aa2b19c952fea13377208697971dc26ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b19c952fea13377208697971dc26ec">&#9670;&#160;</a></span>AsOriginal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> AsOriginal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> std::vector&lt; <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>propertyTolerance</em> = <code>{}</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function condenses all coplanar faces in the relation, and collapses those edges. In the process the relation to ancestor meshes is lost and this new <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> is marked an original. <a class="el" href="namespacemanifold.html#structmanifold_1_1_properties">Properties</a> are preserved, so if they do not match across an edge, that edge will be kept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propertyTolerance</td><td>A vector of precision values for each property beyond position. If specified, the propertyTolerance vector must have size = numProp - 3. This is the amount of interpolation error allowed before two neighboring triangles are considered to be on a property boundary edge. Property boundary edges will be retained across operations even if the triangles are coplanar. Defaults to 1e-5, which works well for most single-precision properties in the [-1, 1] range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d7e7e674ce7bd9954dc0d54ec6ebc8c" name="a1d7e7e674ce7bd9954dc0d54ec6ebc8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7e7e674ce7bd9954dc0d54ec6ebc8c">&#9670;&#160;</a></span>ReserveIDs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmanifold_1_1_transform_iterator.html">uint32_t</a> ReserveIDs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">uint32_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the first of n sequential new unique mesh IDs for marking sets of triangles that can be looked up after further operations. Assign to <a class="el" href="structmanifold_1_1_mesh_g_l_p.html#aa67d01a9b240154a754945eca9fca3e0">MeshGL.runOriginalID</a> vector. </p>

</div>
</div>
<a id="a78fbea69555ea755f8731255060f7c9d" name="a78fbea69555ea755f8731255060f7c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fbea69555ea755f8731255060f7c9d">&#9670;&#160;</a></span>Translate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Translate </td>
          <td>(</td>
          <td class="paramtype">vec3&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move this <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> in space. This operation can be chained. Transforms are combined and applied lazily.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to add to every vertex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6153eb69d3a69e38e6508bf58449f04" name="aa6153eb69d3a69e38e6508bf58449f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6153eb69d3a69e38e6508bf58449f04">&#9670;&#160;</a></span>Scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Scale </td>
          <td>(</td>
          <td class="paramtype">vec3&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale this <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> in space. This operation can be chained. Transforms are combined and applied lazily.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to multiply every vertex by per component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f74bf3b7c5dd34e84b82e7738fd25ff" name="a7f74bf3b7c5dd34e84b82e7738fd25ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f74bf3b7c5dd34e84b82e7738fd25ff">&#9670;&#160;</a></span>Rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>xDegrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>yDegrees</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>zDegrees</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies an Euler angle rotation to the manifold, first about the X axis, then Y, then Z, in degrees. We use degrees so that we can minimize rounding error, and eliminate it completely for any multiples of 90 degrees. Additionally, more efficient code paths are used to update the manifold when the transforms only rotate by multiples of 90 degrees. This operation can be chained. Transforms are combined and applied lazily.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xDegrees</td><td>First rotation, degrees about the X-axis. </td></tr>
    <tr><td class="paramname">yDegrees</td><td>Second rotation, degrees about the Y-axis. </td></tr>
    <tr><td class="paramname">zDegrees</td><td>Third rotation, degrees about the Z-axis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4459c0e7355b2805b2694da075c8346" name="af4459c0e7355b2805b2694da075c8346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4459c0e7355b2805b2694da075c8346">&#9670;&#160;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> mat4x3 &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform this <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> in space. The first three columns form a 3x3 matrix transform and the last is a translation vector. This operation can be chained. Transforms are combined and applied lazily.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The affine transform matrix to apply to all the vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad76d89178ca970900c81f2927f8c7f11" name="ad76d89178ca970900c81f2927f8c7f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76d89178ca970900c81f2927f8c7f11">&#9670;&#160;</a></span>Mirror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Mirror </td>
          <td>(</td>
          <td class="paramtype">vec3&#160;</td>
          <td class="paramname"><em>normal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mirror this <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> over the plane described by the unit form of the given normal vector. If the length of the normal is zero, an empty <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> is returned. This operation can be chained. Transforms are combined and applied lazily.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normal</td><td>The normal vector of the plane to be mirrored over </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5366f7082adcbb2be63fcf2b4c57eb51" name="a5366f7082adcbb2be63fcf2b4c57eb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5366f7082adcbb2be63fcf2b4c57eb51">&#9670;&#160;</a></span>Warp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Warp </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; <a class="el" href="structmanifold_1_1_transform_iterator.html">void</a>(vec3 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>warpFunc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does not change the topology, but allows the vertices to be moved according to any arbitrary input function. It is easy to create a function that warps a geometrically valid object into one which overlaps, but that is not checked here, so it is up to the user to choose their function with discretion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">warpFunc</td><td>A function that modifies a given vertex position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7825d52e3102cc6e7d48a19f9ea0b468" name="a7825d52e3102cc6e7d48a19f9ea0b468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7825d52e3102cc6e7d48a19f9ea0b468">&#9670;&#160;</a></span>WarpBatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> WarpBatch </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; <a class="el" href="structmanifold_1_1_transform_iterator.html">void</a>(<a class="el" href="classmanifold_1_1_vec_view.html">VecView</a>&lt; vec3 &gt;)&gt;&#160;</td>
          <td class="paramname"><em>warpFunc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classmanifold_1_1_manifold.html#a5366f7082adcbb2be63fcf2b4c57eb51">Manifold::Warp</a> but calls warpFunc with with a <a class="el" href="classmanifold_1_1_vec_view.html">VecView</a> which is roughly equivalent to std::span pointing to all vec3 elements to be modified in-place</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">warpFunc</td><td>A function that modifies multiple vertex positions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a852721876d6fce2136ac27e7377f8e" name="a6a852721876d6fce2136ac27e7377f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a852721876d6fce2136ac27e7377f8e">&#9670;&#160;</a></span>SetProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> SetProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="structmanifold_1_1_transform_iterator.html">void</a>(<a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> *, vec3, <a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">double</a> *)&gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new copy of this manifold with updated vertex properties by supplying a function that takes the existing position and properties as input. You may specify any number of output properties, allowing creation and removal of channels. Note: undefined behavior will result if you read past the number of input properties or write past the number of output properties.</p>
<p>If propFunc is a nullptr, this function will just set the channel to zeroes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numProp</td><td>The new number of properties per vertex. </td></tr>
    <tr><td class="paramname">propFunc</td><td>A function that modifies the properties of a given vertex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19abb297f7b7b43f5c84562bcc7df705" name="a19abb297f7b7b43f5c84562bcc7df705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19abb297f7b7b43f5c84562bcc7df705">&#9670;&#160;</a></span>CalculateCurvature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> CalculateCurvature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">int</a>&#160;</td>
          <td class="paramname"><em>gaussianIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">int</a>&#160;</td>
          <td class="paramname"><em>meanIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Curvature is the inverse of the radius of curvature, and signed such that positive is convex and negative is concave. There are two orthogonal principal curvatures at any point on a manifold, with one maximum and the other minimum. Gaussian curvature is their product, while mean curvature is their sum. This approximates them for every vertex and assigns them as vertex properties on the given channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gaussianIdx</td><td>The property channel index in which to store the Gaussian curvature. An index &lt; 0 will be ignored (stores nothing). The property set will be automatically expanded to include the channel index specified.</td></tr>
    <tr><td class="paramname">meanIdx</td><td>The property channel index in which to store the mean curvature. An index &lt; 0 will be ignored (stores nothing). The property set will be automatically expanded to include the channel index specified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6c0e49ed98c9c03bc1324d4ff8452ce" name="ab6c0e49ed98c9c03bc1324d4ff8452ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c0e49ed98c9c03bc1324d4ff8452ce">&#9670;&#160;</a></span>CalculateNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> CalculateNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">int</a>&#160;</td>
          <td class="paramname"><em>normalIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>minSharpAngle</em> = <code>60</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills in vertex properties for normal vectors, calculated from the mesh geometry. Flat faces composed of three or more triangles will remain flat.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normalIdx</td><td>The property channel in which to store the X values of the normals. The X, Y, and Z channels will be sequential. The property set will be automatically expanded such that NumProp will be at least normalIdx + 3.</td></tr>
    <tr><td class="paramname">minSharpAngle</td><td>Any edges with angles greater than this value will remain sharp, getting different normal vector properties on each side of the edge. By default, no edges are sharp and all normals are shared. With a value of zero, the model is faceted and all normals match their triangle normals, but in this case it would be better not to calculate normals at all. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0cbb9710c375f40591c3ae2dd62f2b4" name="aa0cbb9710c375f40591c3ae2dd62f2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0cbb9710c375f40591c3ae2dd62f2b4">&#9670;&#160;</a></span>SmoothByNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> SmoothByNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">int</a>&#160;</td>
          <td class="paramname"><em>normalIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Smooths out the <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> by filling in the halfedgeTangent vectors. The geometry will remain unchanged until Refine or RefineToLength is called to interpolate the surface. This version uses the supplied vertex normal properties to define the tangent vectors. Faces of two coplanar triangles will be marked as quads, while faces with three or more will be flat.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normalIdx</td><td>The first property channel of the normals. NumProp must be at least normalIdx + 3. Any vertex where multiple normals exist and don't agree will result in a sharp edge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b59680c4bc2300e0e12713ab220d3d5" name="a0b59680c4bc2300e0e12713ab220d3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b59680c4bc2300e0e12713ab220d3d5">&#9670;&#160;</a></span>SmoothOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> SmoothOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>minSharpAngle</em> = <code>60</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>minSmoothness</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Smooths out the <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> by filling in the halfedgeTangent vectors. The geometry will remain unchanged until Refine or RefineToLength is called to interpolate the surface. This version uses the geometry of the triangles and pseudo-normals to define the tangent vectors. Faces of two coplanar triangles will be marked as quads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minSharpAngle</td><td>degrees, default 60. Any edges with angles greater than this value will remain sharp. The rest will be smoothed to G1 continuity, with the caveat that flat faces of three or more triangles will always remain flat. With a value of zero, the model is faceted, but in this case there is no point in smoothing.</td></tr>
    <tr><td class="paramname">minSmoothness</td><td>range: 0 - 1, default 0. The smoothness applied to sharp angles. The default gives a hard edge, while values &gt; 0 will give a small fillet on these sharp edges. A value of 1 is equivalent to a minSharpAngle of 180 - all edges will be smooth. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d9227a2d10d8ad7b005555213ecd1ac" name="a5d9227a2d10d8ad7b005555213ecd1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9227a2d10d8ad7b005555213ecd1ac">&#9670;&#160;</a></span>Refine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Refine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increase the density of the mesh by splitting every edge into n pieces. For instance, with n = 2, each triangle will be split into 4 triangles. Quads will ignore their interior triangle bisector. These will all be coplanar (and will not be immediately collapsed) unless the Mesh/Manifold has halfedgeTangents specified (e.g. from the <a class="el" href="classmanifold_1_1_manifold.html#aff03aac40d42a60f8e4254db90530c83">Smooth()</a> constructor), in which case the new vertices will be moved to the interpolated surface according to their barycentric coordinates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of pieces to split every edge into. Must be &gt; 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1381728e52975862d954032f717106d5" name="a1381728e52975862d954032f717106d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1381728e52975862d954032f717106d5">&#9670;&#160;</a></span>RefineToLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> RefineToLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increase the density of the mesh by splitting each edge into pieces of roughly the input length. Interior verts are added to keep the rest of the triangulation edges also of roughly the same length. If halfedgeTangents are present (e.g. from the <a class="el" href="classmanifold_1_1_manifold.html#aff03aac40d42a60f8e4254db90530c83">Smooth()</a> constructor), the new vertices will be moved to the interpolated surface according to their barycentric coordinates. Quads will ignore their interior triangle bisector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The length that edges will be broken down to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c458bbdad94b7445158f0f2d4cdb62c" name="a6c458bbdad94b7445158f0f2d4cdb62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c458bbdad94b7445158f0f2d4cdb62c">&#9670;&#160;</a></span>RefineToPrecision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> RefineToPrecision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>precision</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increase the density of the mesh by splitting each edge into pieces such that any point on the resulting triangles is roughly within precision of the smoothly curved surface defined by the tangent vectors. This means tightly curving regions will be divided more finely than smoother regions. If halfedgeTangents are not present, the result will simply be a copy of the original. Quads will ignore their interior triangle bisector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">precision</td><td>The desired maximum distance between the faceted mesh produced and the exact smoothly curving surface. All vertices are exactly on the surface, within rounding error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9aad9d9b9a58ff2b7622de673742d1df" name="a9aad9d9b9a58ff2b7622de673742d1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aad9d9b9a58ff2b7622de673742d1df">&#9670;&#160;</a></span>Boolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Boolean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___core.html#gaa1aa1c6a8f3bbed5b167bc2d4511b969">OpType</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The central operation of this library: the Boolean combines two manifolds into another by calculating their intersections and removing the unused portions. <a href="https://github.com/elalish/manifold/wiki/Manifold-Library#definition-of-%CE%B5-valid">&epsilon;-valid</a> inputs will produce &epsilon;-valid output. &epsilon;-invalid input may fail triangulation.</p>
<p>These operations are optimized to produce nearly-instant results if either input is empty or their bounding boxes do not overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">second</td><td>The other <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>. </td></tr>
    <tr><td class="paramname">op</td><td>The type of operation to perform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b30c42e224bda7e71a3ed3cf02319c1" name="a1b30c42e224bda7e71a3ed3cf02319c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b30c42e224bda7e71a3ed3cf02319c1">&#9670;&#160;</a></span>BatchBoolean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> BatchBoolean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> std::vector&lt; <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>manifolds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___core.html#gaa1aa1c6a8f3bbed5b167bc2d4511b969">OpType</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform the given boolean operation on a list of Manifolds. In case of Subtract, all Manifolds in the tail are differenced from the head. </p>

</div>
</div>
<a id="af95e73e5427d09b9d9e025d5cf367c30" name="af95e73e5427d09b9d9e025d5cf367c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95e73e5427d09b9d9e025d5cf367c30">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand for Boolean Union. </p>

</div>
</div>
<a id="a530ec6ae990090f4b5c52f0d32eb2688" name="a530ec6ae990090f4b5c52f0d32eb2688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530ec6ae990090f4b5c52f0d32eb2688">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp; <a class="el" href="structmanifold_1_1_transform_iterator.html">operator</a>+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand for Boolean Union assignment. </p>

</div>
</div>
<a id="ad9da8c505e6846e9645008825833e1da" name="ad9da8c505e6846e9645008825833e1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9da8c505e6846e9645008825833e1da">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand for Boolean Difference. </p>

</div>
</div>
<a id="ae17823c1f0efdfa41324892e52ab1f2b" name="ae17823c1f0efdfa41324892e52ab1f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17823c1f0efdfa41324892e52ab1f2b">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp; <a class="el" href="structmanifold_1_1_transform_iterator.html">operator</a>-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand for Boolean Difference assignment. </p>

</div>
</div>
<a id="ad1e4e5720f01934c44aebc597be4d104" name="ad1e4e5720f01934c44aebc597be4d104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e4e5720f01934c44aebc597be4d104">&#9670;&#160;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> <a class="el" href="structmanifold_1_1_transform_iterator.html">operator</a>^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand for Boolean Intersection. </p>

</div>
</div>
<a id="a88768bbf9fabf89e72b27a45321b6522" name="a88768bbf9fabf89e72b27a45321b6522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88768bbf9fabf89e72b27a45321b6522">&#9670;&#160;</a></span>operator^=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp; <a class="el" href="structmanifold_1_1_transform_iterator.html">operator</a>^= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand for Boolean Intersection assignment. </p>

</div>
</div>
<a id="a60e241b8a56d334b3d2d3dbd2fc808ba" name="a60e241b8a56d334b3d2d3dbd2fc808ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e241b8a56d334b3d2d3dbd2fc808ba">&#9670;&#160;</a></span>Split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>, <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &gt; Split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>cutter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split cuts this manifold in two using the cutter manifold. The first result is the intersection, second is the difference. This is more efficient than doing them separately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cutter</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40c2716b965886e4fb952e5ade866a5a" name="a40c2716b965886e4fb952e5ade866a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c2716b965886e4fb952e5ade866a5a">&#9670;&#160;</a></span>SplitByPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a>, <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &gt; SplitByPlane </td>
          <td>(</td>
          <td class="paramtype">vec3&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>originOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient version of <a class="el" href="classmanifold_1_1_manifold.html#a60e241b8a56d334b3d2d3dbd2fc808ba">Split()</a> for a half-space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normal</td><td>This vector is normal to the cutting plane and its length does not matter. The first result is in the direction of this vector, the second result is on the opposite side. </td></tr>
    <tr><td class="paramname">originOffset</td><td>The distance of the plane from the origin in the direction of the normal vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8d62161da6e94da7651418c33c3e294" name="aa8d62161da6e94da7651418c33c3e294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d62161da6e94da7651418c33c3e294">&#9670;&#160;</a></span>TrimByPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> TrimByPlane </td>
          <td>(</td>
          <td class="paramtype">vec3&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>originOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="classmanifold_1_1_manifold.html#a40c2716b965886e4fb952e5ade866a5a">SplitByPlane()</a>, but calculating and returning only the first result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normal</td><td>This vector is normal to the cutting plane and its length does not matter. The result is in the direction of this vector from the plane. </td></tr>
    <tr><td class="paramname">originOffset</td><td>The distance of the plane from the origin in the direction of the normal vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad03837de2290a269fa14e0773c9913fa" name="ad03837de2290a269fa14e0773c9913fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03837de2290a269fa14e0773c9913fa">&#9670;&#160;</a></span>Slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemanifold.html#a60a66d8ddacc086bb45d8afc37f646d1">Polygons</a> Slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">double</a>&#160;</td>
          <td class="paramname"><em>height</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the cross section of this object parallel to the X-Y plane at the specified Z height, defaulting to zero. Using a height equal to the bottom of the bounding box will return the bottom faces, while using a height equal to the top of the bounding box will return empty. </p>

</div>
</div>
<a id="a328657b69e9bbaaee148572ca314677c" name="a328657b69e9bbaaee148572ca314677c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328657b69e9bbaaee148572ca314677c">&#9670;&#160;</a></span>Project()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemanifold.html#a60a66d8ddacc086bb45d8afc37f646d1">Polygons</a> Project </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns polygons representing the projected outline of this object onto the X-Y plane. These polygons will often self-intersect, so it is recommended to run them through the positive fill rule of <a class="el" href="classmanifold_1_1_cross_section.html">CrossSection</a> to get a sensible result before using them. </p>

</div>
</div>
<a id="a9dc9e00112e2b063cfa6fe8482b1afe8" name="a9dc9e00112e2b063cfa6fe8482b1afe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc9e00112e2b063cfa6fe8482b1afe8">&#9670;&#160;</a></span>Hull() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Hull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the convex hull of this manifold. </p>

</div>
</div>
<a id="a0b45afc24015963e82745f1f83f3f310" name="a0b45afc24015963e82745f1f83f3f310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b45afc24015963e82745f1f83f3f310">&#9670;&#160;</a></span>Hull() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Hull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> std::vector&lt; <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>manifolds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the convex hull enveloping a set of manifolds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manifolds</td><td>A vector of manifolds over which to compute a convex hull. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0a6fa5c97e3e47118ee69b741e64ad0" name="ab0a6fa5c97e3e47118ee69b741e64ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a6fa5c97e3e47118ee69b741e64ad0">&#9670;&#160;</a></span>Hull() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> Hull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> std::vector&lt; vec3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>pts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the convex hull of a set of points. If the given points are fewer than 4, or they are all coplanar, an empty <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pts</td><td>A vector of 3-dimensional points over which to compute a convex hull. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a611a5fd95dc5d49cd88182b8ead722b7" name="a611a5fd95dc5d49cd88182b8ead722b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611a5fd95dc5d49cd88182b8ead722b7">&#9670;&#160;</a></span>MatchesTriNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmanifold_1_1_transform_iterator.html">bool</a> MatchesTriNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The triangle normal vectors are saved over the course of operations rather than recalculated to avoid rounding error. This checks that triangles still match their normal vectors within <a class="el" href="classmanifold_1_1_manifold.html#aef800826805cb6d90d03846fdb12c3e3">Precision()</a>. </p>

</div>
</div>
<a id="af46a22b8e84924f7159ae2a2db6cc956" name="af46a22b8e84924f7159ae2a2db6cc956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46a22b8e84924f7159ae2a2db6cc956">&#9670;&#160;</a></span>NumDegenerateTris()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmanifold_1_1_transform_iterator.html">size_t</a> NumDegenerateTris </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of triangles that are colinear within <a class="el" href="classmanifold_1_1_manifold.html#aef800826805cb6d90d03846fdb12c3e3">Precision()</a>. This library attempts to remove all of these, but it cannot always remove all of them without changing the mesh by too much. </p>

</div>
</div>
<a id="a83f15752f22381625ec9f04e1488fc69" name="a83f15752f22381625ec9f04e1488fc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f15752f22381625ec9f04e1488fc69">&#9670;&#160;</a></span>NumOverlaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmanifold_1_1_transform_iterator.html">size_t</a> NumOverlaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmanifold_1_1_transform_iterator.html">const</a> <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a checksum-style verification of the collider, simply returning the total number of edge-face bounding box overlaps between this and other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A <a class="el" href="classmanifold_1_1_manifold.html">Manifold</a> to overlap with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemanifold.html">manifold</a></li><li class="navelem"><a class="el" href="classmanifold_1_1_manifold.html">Manifold</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
